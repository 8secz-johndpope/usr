#
# slim.ini $Revision: #1 $:
#   the .ini file for slim-specific preferences.
#
#   Available commands:
#       SetPref name value
#       LockPref name value
#       LoadExtension class filename
#   
#   In addition, you can use standard safe-tcl commands
#   to perform calculations and substitutions.  We also
#   provide the following procs:
#       RATGetDir $dir - returns the path to a rat subdir:
#           $dir can be lib, etc, resource, home
#       GetPref name - returns the current value of a pref.
#       LogMsg code msg - logs a message at a level indicated
#           by code which should be one of:
#               COPIOUS, INFO, NOTICE, WARNING, ERROR
#
#
# Slim Extensions

namespace eval ::Slim {}; #create the ::Slim namespace for globals

# source registration/menu procedures used below
source [file join [RATGetDir etc] SlimInit.tcl]

set templates [file join [RATGetDir lib] slim]
set clientmode [::Slim::GetClientMode]

# to support different suites of templates we can add their name to this list.
# This will facilitate loading the templates as live or as legacy.
# To load the allPurpose template from RMS 3 set TemplateSuite to include 
# allPurpose i.e. SetPref TemplateSuite {allPurpose} in RMS.ini

SetPref TemplateSuite "[GetPref TemplateSuite] null" 

# TemplateSearchPaths is a tcl list of directories
SetPref TemplateSearchPaths [list $templates]

# require slim extensions  .............................................
# extensions of type slim are loaded at startup. We recommend
# that all customui, macros, visualizers and converters be "pre-loaded".
#
LoadExtension slim [file join $templates floatsplineui.slim] customui
LoadExtension slim [file join $templates splineui.slim] customui
LoadExtension slim [file join $templates layerui.slim] customui
LoadExtension slim [file join $templates layerui2.slim] customui
LoadExtension slim [file join $templates adaptorui.slim] customui
LoadExtension slim [file join $templates addparamui.slim] customui
LoadExtension slim [file join $templates allPurposeui.slim] customui
LoadExtension slim [file join $templates bigstringui.slim] customui
LoadExtension slim [file join $templates combineui.slim] customui
LoadExtension slim [file join $templates customui.slim] customui
LoadExtension slim [file join $templates customcmd.slim] customcmd
LoadExtension slim [file join $templates noiseui.slim] customui
LoadExtension slim [file join $templates listui.slim] customui
LoadExtension slim [file join $templates visui.slim] customui

# these extensions are required for basic slim operation.
LoadExtension slim [file join $templates aovmacros.slim] customui
LoadExtension slim [file join $templates conversion.slim] slim
LoadExtension slim [file join $templates visualizers.slim] slim
if {$clientmode eq "mtor"} {
    LoadExtension slim [file join $templates legacy/legacyVisualizer.slim] slim
}  else {
    LoadExtension slim [file join $templates rfm/rfmVisualizers.slim] slim
}
LoadExtension tcl [file join [RATGetDir etc] SlimClientExpression.tcl]
LoadExtension tcl [file join [RATGetDir etc] SlimExpression.tcl]
LoadExtension tcl [file join [RATGetDir etc] SlimBuildShaderMetadata.tcl]

# type used by the "multiple" visualizer
# any nodes with multiple outputs will need their types
# to be able to convert to this type
SetPref MultipleVisualizerInputType shadingmodel

# preferences for automatic type conversion
# these define the template that will convert
# from the first type to the second
# entries marked as "hidden" are only used by the "multiple" visualizer
SetPref TypeConversionTemplate(float,color) \
        pixar,ConvertFloatToColor
SetPref TypeConversionTemplate(color,float) \
        pixar,ConvertColorToFloat
SetPref TypeConversionTemplate(vector,normal) \
        pixar,ConvertVectorToNormal
SetPref TypeConversionTemplate(normal,vector) \
        pixar,ConvertNormalToVector
SetPref TypeConversionTemplate(shadingcomponent,color) \
        pixar,ConvertSCToColor
SetPref TypeConversionTemplate(color,shadingcomponent) \
        pixar,ConvertColorToSC
SetPref TypeConversionTemplate(shadingmodel,color) \
        pixar,ConvertSMToColor
SetPref TypeConversionTemplate(color,shadingmodel) \
        pixar,ConvertColorToSM
SetPref TypeConversionTemplate(shadingmodel,shadingmodel_aov) \
        pixar,ConvertSMToSMaov
SetPref TypeConversionTemplate(shadingmodel_aov,shadingmodel) \
        pixar,ConvertSMaovToSM
SetPref TypeConversionTemplate(normal,color) \
        pixar,ConvertNormalToColor
SetPref TypeConversionTemplate(color,normal) \
        pixar,ConvertColorToNormal
SetPref TypeConversionTemplate(color,vector) \
        pixar,ConvertColorToVector
SetPref TypeConversionTemplate(color,point) \
        pixar,ConvertColorToPoint
SetPref TypeConversionTemplate(vector,color) \
        pixar,ConvertVectorToColor

# these are only useful for the "multiple" visualizer
SetPref TypeConversionTemplate(float,shadingmodel) \
        {pixar,ConvertFloatToSM hidden}
SetPref TypeConversionTemplate(point,shadingmodel) \
        {pixar,ConvertPointToSM hidden}
SetPref TypeConversionTemplate(vector,shadingmodel) \
        {pixar,ConvertVectorToSM hidden}
SetPref TypeConversionTemplate(normal,shadingmodel) \
        {pixar,ConvertNormalToSM hidden}
SetPref TypeConversionTemplate(manifold,shadingmodel) \
        {pixar,ConvertManifoldToSM hidden}

# URLs for the Help menu
SetPref HelpURLs(slim) { 
    "Slim Documentation"
    http://renderman.pixar.com/resources/current/rms/slimQuickRef.html
}

# interface preferences
SetPref RaiseSlim 1
SetPref InstanceStructure hierarchical; # hierarchical, flat, grouped
SetPref ExpertMenus 0

SetPref RenderInstancesWhenUpdating 1
SetPref BrowseIconSize 20
SetPref CreateIconSize 20
SetPref ShowAppearanceNotes 0
SetPref ShowAppearanceTags 0
SetPref ValueSetColor "#000044"
SetPref ValueUnsetColor "#444444"
SetPref CascadeMenuSize 16
SetPref DefaultSliderPrecision 0.01
SetPref ShowPathInAppEditorTitle 1
SetPref SlimWindowViewStyle threecolumn
SetPref FilePickerShowHidden 0

# A time interval in milliseconds every which to check for read-only status on
# disk-based palettes. Use 0 to never check, values under 200 are clamped to 200
SetPref StatPalettes 1000

# Enable delayed loading of palettes
SetPref LazyPaletteLoad 1

# Whether library palettes should be removed and reloaded in a
# slim Clear operation
SetPref ClearLibraryPalettes 0

# Create a new palette if there are no palettes in Slim
SetPref CreateDefaultPalette 1

# Allow for the ability to drag an appearance into another appearance
# to create node collections
SetPref EnableAppearanceHierarchies 1

# Put up a message box error for each time a template has two properties
# with the same name
SetPref LoudDuplicateNamingError    0

# preview preferences

# rendering
# to plug in your own renderer, place your rendering command
# here.  Note that %f and %i are substituted by the RIB
# filename and the slim internal image name.  To cause
# send your pixels to slim, invoke sho -dspy slim -dspyfile %i %i
#
#     LockPref PreviewRenderer "prman %f"
#
SetPref PreviewRenderer internal
SetPref PreviewResolution 120
SetPref PreviewShadingRate 1
SetPref PreviewProcsUsed all
SetPref PreviewBucketsPerRow 4
SetPref PreviewPixelSamples {3 3}
SetPref PreviewPixelFilter {"catmull-rom" 3 3}
SetPref CustomDisplay ""
SetPref TextureDisplay ""

# object
SetPref PreviewObjectSize  1
SetPref PreviewObjectShape Sphere
SetPref PreviewObjectArchive ""
SetPref PreviewFrameVisible 0

# lights
SetPref PreviewSimpleLights 1
SetPref KeyLight {.8 .8 .8}
SetPref FillLight {.2 .2 .2}
SetPref AmbientLight {.05 .05 .05}
SetPref PreviewLightArchive ""

# environment light
SetPref PreviewEnvLight 1
SetPref PreviewEnvMap ratEnvInterior.tex
SetPref PreviewDiffEnvMap ratEnvInteriorSmall.tex
SetPref PreviewEnvKd 1
SetPref PreviewEnvDiffuseBlur 0.2
SetPref PreviewEnvKs 1
SetPref PreviewEnvKs 1
# AP specific environment light controls
SetPref PreviewEnvFeatures 0

# scene
SetPref PreviewUpAxis Y
SetPref PreviewBackgroundTexture ratGrid.tex
SetPref PreviewBackgroundApplySRGB 0
SetPref PreviewSceneSphere 1
SetPref PreviewSceneSphereTexture ratEnvInterior.tex

SetPref FlipbookFrameCount 32
SetPref FlipbookResolution 128
#SetPref FlipbookRenderer prman
#SetPref FlipbookRenderer netrender 
SetPref FlipbookRenderer internal
#SetPref TextureRenderer "alfred -n 6 -rm %f"
#SetPref TextureRenderer "prman %f"
SetPref TextureRenderer "internal"
SetPref TextureResolution 512
SetPref SeqBegin 1
SetPref SeqEnd 100

# file preferences
SetPref SaveIcons attachable
SetPref SavedIconResolution 60
SetPref PreferFullPaths 0
SetPref DereferenceMasterDirectory 0
SetPref CheckpointQueueSize 0


# shader generation / compile settings

# 
# When enabled external parameters names of shaders are controlled by the 
# Custom Overview
SetPref SlimSLNamesFromCustomOverview 0

# When Custom Overview parameter naming is in effect should the hierarchy
# of the collections be included in the parameter name
SetPref SlimSLUseCustomOverviewHierarchy 1

SetPref ShaderHeader {}
SetPref ShaderCompiler [list $RMANTREE/bin/shader \
                        -I$RMSTREE/lib/shaders \
                        -I$RMSTREE/lib/slim/include \
                        -I$RMSTREE/lib/slim/pxCoreV1 \
                        -I$RMSTREE/lib/slim/pxslInterfacesV1 \
                        -I$RMSTREE/lib/rfm/rsl \
                        -C %f]

# network view / graph preferences
SetPref ShowNetworkView 1
# keep nodes from separate networks in non-overlapping zones
SetPref ClusterNodes 1
# edge coloring by type
# first is the master switch:
SetPref GraphColorEdges 1
# then color preferences:
# (the first color is the normal color, the second is the highlight color)
SetPref GraphEdgeColors(surface) {#6688aa #88aaff}
SetPref GraphEdgeColors(shadingmodel) {#6688aa #88aaff}
SetPref GraphEdgeColors(shadingmodel_aov) {#6688aa #88aaff}
SetPref GraphEdgeColors(displacement) {#8888aa #aaaaff}
SetPref GraphEdgeColors(volume) {#8888aa #aaaaff}
SetPref GraphEdgeColors(light) {#aaaa88 #ffffaa}
SetPref GraphEdgeColors(color) {#aa8888 #ffaaaa}
SetPref GraphEdgeColors(manifold) {#88aa88 #aaffaa}

# Available node colors, make sure the three lists have the same number of
# elements
SetPref NodeColors {
    name     { None Red     Yellow  Green   Violet  Blue    }
    normal   { ""   #b03060 #cd853f #8fbc8f #9370db #3a5fcd }
    selected { ""   #db7093 #f4a460 #3cb371 #8a2be2 #0000cd }
}

# animated focus, relayout
# this is how long a change takes. set to zero to disable animation
SetPref GraphFocusDuration 400
SetPref GraphLayoutDuration 400
SetPref DefaultAutoFocusEnabled 1

# default graph arrange preference (auto|manual|smart)
# in "smart" mode new layouts are made in the same mode as the last
# layout that was being used.
SetPref DefaultArrangeMethod auto

# if you want to see warnings from shader compiles, set this to your
# desired loglevel, e.g. WARNING
SetPref CompilerWarningLogLevel ""

# embed slim info as meta info inside of slim shaders
# this is recommended when using Slim with RenderMan for Maya
SetPref EmbedSlimData 1

# deprecated preferences
SetPref OrganizeByVendor 0
SetPref PreferVSlider 0
SetPref ShowHub 0
SetPref GenerateSli 0; # 1 -> glimpse compatibility.
# Use workspace Globalize to find an output path instead of
# writing (and creating) the directory specified in the workspace.
# Old, potentially dangerous and deprecated, don't enable unless you
# really know you want this
SetPref OldOutputPathLogic 0

LockPref RManCtls 1

# DefaultMasterRef
# controls default asset reference for code-generated shaders that can
# be attached to scene objects. You may want to carefully choose your
# default master reference to best fit your studios' production 
# collaboration practices.  Many variables are predefined. You can 
# define additional variables within the SetInstanceExpressionContext 
# procedure  (in SlimExpression.tcl). By default, that procedure defines
# the PALETTENAME variable, which is set to be the label of the
# appearance's palette.
#
if {$clientmode ne "mtor"} {
    set refUser {$slimShaders/$USER/$INSTANCENAME}
        # If you have lots of users working in the same project
    set refInstId {$slimShaders/${INSTANCENAME}_$INSTANCEID}
        # You may wish to include the unique instance id in your shader name.
        # This will prevent any shader name conflicts between appearances
    set refInstNm {$slimShaders/${NAMESPACE}$INSTANCENAME}
        # This simple setting is generally applicable, so default.
    set masterRef $refInstNm
} else {
    # mtor legacy mode:
    set refUser {$torShaders/$USER/$INSTANCENAME}
    set refInstId {$torShaders/${INSTANCENAME}_$INSTANCEID}
    set refInstNm {$torShaders/$INSTANCENAME}
    set masterRef $refInstNm
}
SetPref DefaultMasterRef $masterRef

#
# Should slim checkpoint a session file each time the client saves.
# Users checkpoint at any time using the File->Checkpoint Session option
# Since tight tethering mode stores session files in the client's scene 
# we default to off in that case since it is like the user would be
# checkpointing the scene to accomplish the same
SetPref CheckpointAtClientSave 1
SetPref CheckpointAtClientSaveInTightMode 0

# This controls whether to make use of file references stored in template hints
# when loading a template that hasn't been registered
SetPref UseTemplateHintFileReferences 1

# These preferences control how Slim keeps appearance names unique.
# UniqueNameDomain describes how the scope in which names are unique.
# Valid options are:
#  - session : appearances in current session
#  - palette : appearances in a palette
#  - group   : appearances in a group
#  - history : all compiled appearances in the shading directory
#
# Names are initially unique, but are only continuously checked
# when MaintainUniqueNames is turned on.
#
# MaintainUniqueNames is only valid for UniqueNameDomains other than
# history.  For these domains, it is recommended that you include the
# instance id in the master name (see above).  The following settings 
# describe the behavior of previous slim releases:
#
# SetPref UniqueNameDomain history
# SetPref MaintainUniqueNames 0
#
# But we recommend using these settings:

SetPref UniqueNameDomain session
SetPref MaintainUniqueNames 1

# Default txmake settings
# These are classified by subtype (as referenced in template)
SetPref TxmakeArgs(environment) { -envlatl -smode black -tmode black -resize up}
SetPref TxmakeArgs(reflection) { -smode black -tmode black -resize up}
SetPref TxmakeArgs(shadow) { -shadow -smode black -tmode black -resize none}
SetPref TxmakeArgs(texture) { -smode periodic -tmode periodic -resize up-}

# this is the color for read-only palettes
LockPref ROColor #8080a0

# SlimAttachableMap:
#   describes the association between custom Slim template types
#   and known attachable appearance types:
#       surface, coshader, displacement, light, ribbox, tclbox, 
#       ensemble, mapgen, dso, archiver, volume
#   If you develop a new Slim template type that requires attachment
#   semantics, simply add a SlimAttachableMap entry of the form:
#
#       SetPref SlimAttachableMap(yourtype) {systemtype1 systemtype2 ...}
#
SetPref SlimAttachableMap(shadingmodel) surface
SetPref SlimAttachableMap(shadingmodel_aov) surface
SetPref SlimAttachableMap(visualizer) surface
SetPref SlimAttachableMap(material) {surface coshader}
SetPref SlimAttachableMap(codisplacement) coshader
SetPref SlimAttachableMap(lightblocker) {coshader}
SetPref SlimAttachableMap(volume) {atmosphere interior exterior}
SetPref SlimAttachableMap(volumematerial) {surface}
SetPref SlimAttachableMap(Imager) {imager pixelsampleimager}

# prefs controlling attachment semantics - available only in RfM, not MTOR.
SetPref ClientAttachShapesOnly 1; # 0: attachable at intermediate transform
                                  # 1: attachable only at shape nodes
SetPref ClientAttachMasterLayerOnly 0; # 0: attachable in current render layer
                                       # 1: attachable only on master layer

SetPref SlimHiddenTemplateTypes visualizer

# SlimUniqueClientInstances:
#   when attached to a Slim client, this pref controls whether
#   to request one-instance-only behavior within the client.
#   when set to 0, you can add an instance multiple times,
#   when set to 1, invoking add-to-scene multiple times will result
#   in only a single instance.
SetPref SlimUniqueClientInstances 1

# Hold onto the last few selected style context strings
SetPref SlimMaxMRUStyleContextStrings 8

# Library Palettes ---
#
# These palettes are used to store a library of reusable shaders
#
SetPref ReadOnlyLibrary 0
    # This controls if palettes should be forced read-only on load

SetPref LibraryPaletteSets { factory personal }
    # This preference specifies the list of "sets" of library palettes.
    # Sets will be loaded in the order you specify.

# factory ---
SetPref LibraryPaletteDir(factory) [file join [RATGetDir lib] slimPalettes]
    # each set of library palettes can reside in a particular dir
    # controlled by this pref.

# LibraryPaletteDefs: allows you to define the list of library  palettes
#   available to all users.  Each user can manipulate the state of
#   these palettes and add their own personal library palettes.
#   The state of library palettes is stored in the pref LibraryPalettes
set libraryPalettes {}
if {$clientmode ne "mtor"} {
    if {[lsearch [GetPref TemplateSuite]  "allPurpose"] ne -1} {
        set libraryPalettes {
            BasicPackages.splt {
                mode copy
                create 0
            }   
        }
    }
}
SetPref LibraryPaletteDefs(factory) $libraryPalettes

# personal ---
# start with a specification for a personal library palette
# stored within the preferences directory
#
set personalLibDir [file join [RATGetDir prefs] palettes]
if ![file exists $personalLibDir] {
    # create directory if it doesn't exist
    file mkdir $personalLibDir
}
SetPref LibraryPaletteDir(personal) $personalLibDir

# this specifies that a palette MyLibrary.splt will
# be used as a library palette, will operate in "copy" mode,
# and will be created for the user if it doesn't already exist:
SetPref LibraryPaletteDefs(personal) {
    MyLibrary.splt {
        mode copy
        create 1
    }   
}

# this controls whether library palette members are shown
# with templates in the "Create" global smart palettes
#
SetPref IncludeLibraryInSmartPalettes 1

# Smart Palettes
# These smart palettes are always shown in the palette editor
# and are system-wide. The format is the same as what is saved
# in a palette file.
# 
set browseSelectedAppearances {
    smartpalette Selected {
        locked 1
        criterion clientSelected {isTrue}
        state closed
        smartpalette Surfaces {
            locked 1
            criterion attachmenttypes {contains surface}
        }
        smartpalette Coshaders {
            locked 1
            criterion attachmenttypes {contains coshader}
        }
        smartpalette Lights {
            locked 1
            criterion attachmenttypes {contains light}
        }
    }
}
set attachablePalettes {
    smartpalette Attachable {
        locked 1
        criterion attachmenttypes {isNot {}}
        state closed
        smartpalette Ensembles {
            locked 1
            criterion templateType {is ensemble}
        }
        smartpalette Materials {
            locked 1
            criterion templateType {is material}
        }
        smartpalette Surfaces {
            locked 1
            criterion attachmenttypes {contains surface}
            criterion attachmenttypes {doesNotContain coshader}
        }
        smartpalette Coshaders {
            locked 1
            criterion attachmenttypes {is coshader}
            state closed 
            smartpalette Broadcast {
                locked 1
                count any
                criterion name {beginsWith Broadcast}
            }
        }
        smartpalette Displacements {
            locked 1
            count any
            criterion attachmenttypes {is displacement}
            criterion templateType {is codisplacement}
        }
        smartpalette Lights {
            locked 1
            count any
            criterion attachmenttypes {is light}
            criterion attachmenttypes {is arealight}
            criterion templateType {is lightblocker}
        }
        smartpalette Volumes {
            locked 1
            criterion templateType {contains volume}
        }
        smartpalette Imagers {
            locked 1
            criterion attachmenttypes {contains imager}
        }
        smartpalette Utilities {
            locked 1
            criterion templateType {isNot ensemble}
            criterion attachmenttypes {doesNotContain surface}
            criterion attachmenttypes {doesNotContain coshader}
            criterion attachmenttypes {doesNotContain displacement}
            criterion attachmenttypes {doesNotContain light}
            criterion attachmenttypes {doesNotContain atmosphere}
            criterion attachmenttypes {doesNotContain imager}
        }
    }
}    

set subordinatePalettes {
    smartpalette Subordinate {
        locked 1
        criterion attachmenttypes {is ""}
        state closed 
        smartpalette Floats {
            locked 1
            criterion outputtypes {include float}
            state closed
            smartpalette Maps {
                locked 1
                criterion tags {include map}
            }
            smartpalette Pattern {
                locked 1
                criterion tags {include pattern}
            }
            smartpalette Trace {
                locked 1
                criterion tags {include trace}
            }
            smartpalette Insertable {
                locked 1
                criterion tags {include insertable}
            }
            smartpalette Utility {
                locked 1
                criterion tags {include utility}
            }
        }
        smartpalette Colors {
            locked 1
            criterion outputtypes {include color}
            state closed
            smartpalette Maps {
                locked 1
                criterion tags {include map}
            }
            smartpalette Pattern {
                locked 1
                criterion tags {include pattern}
            }
            smartpalette Trace {
                locked 1
                criterion tags {include trace}
            }
            smartpalette Insertable {
                locked 1
                criterion tags {include insertable}
            }
            smartpalette Utility {
                locked 1
                criterion tags {include utility}
            }
        }
        smartpalette Manifolds {
            locked 1
            count any
            criterion outputtypes {include manifold}
            criterion outputtypes {include manifoldn}
        }
        smartpalette Geometry {
            locked 1
            count any
            criterion outputtypes {include point}
            criterion outputtypes {include normal}
            criterion outputtypes {include vector}
        }
        smartpalette Receivers {
            locked 1
            count any
            criterion name {beginsWith Receive}
        }
    }
}

SetPref SmartPalettes(browse) "$browseSelectedAppearances $attachablePalettes $subordinatePalettes"
SetPref SmartPalettes(create) "$attachablePalettes $subordinatePalettes"

# These preferences declare the Smart Palette (referenced by label) to use
# when browsing appearances for connections by type (e.g. in the property menu)
# This is only necessary if you want to see nested smart palettes in the
# connection menu for the given type. Any types not specified here will
# display a menu without any nested smart palettes.
# 
SetPref SmartPaletteForType(color) Colors
SetPref SmartPaletteForType(float) Floats
        
# Define which smart palettes are available in the keyboard-based 
# appearance browser. 
SetPref BrowseablePalettes { create/Attachable create/Subordinate }
SetPref BrowseablePalettesActive { 1 0 }

# How to present the appearances on the properties' menu in the
# Appearance editor. Values can be "menus" (the old method) or
# "keyboard" which brings up the keyboard browser.
SetPref AppearanceSelection keyboard
SetPref KeyboardBrowserSize {200 250}

# optional/replaceable slim templates ...................................
# extensions of type slimtmplt are loaded when needed/used
# we suggest that you adopt a particular level of granularity for
# your custom templates with these considerations in mind:
#   - slim supports multiple templates per file
#   - versioning and lazy loading is most efficient when a
#     single template (and possible all its versions) live
#     in a single file.
#   - lots of files can be an organizational burden
#   - some templates change frequently, others never.
#
# variable lazyTemplateList
#   here we construct a list to pass to ::Slim::RegisterLazyTemplates
#   the structure of the lazyTemplateList is a list of pairs:
#       1. slim file containing one or more template definitions
#       2. a list of lists, each decribing an individual template:
#           1. templateID 2. template type  3. menu label 4. tags 5. icons
#
#   The template type can specified in two formats: either a single word
#   specifying the type of the single output of a template or the description of
#   a template interface: a template interface specifies the type of templates
#   with multiple output types, like this:
#     {outputs {float color}}
#   It can also specify the types for inputs flagged as defaultinput 1 in the
#   template description, so that these templates will appear in the Insert
#   menus in Slim. Here is an example:
#     {outputs {float} input {floats}}
#   which would be appropriate for the Float Remap node.
#   Tags can be used as a criterion in smart palettes, we do this in the smart
#   palettes specified above
#   The format for the icons is a list of pairs, the first specifying the output
#   property the icon refers to and the second specifying the icon itself.
#   The most common case is the following
#   {{} {file myIcon.gif}}
#   this means: all outputs use the icon stored in the file to be found in the
#   resource directories (specified in the ResourceDirs preference)
#

# -------------------------------------------------------------------------
# Invoke the lazy registration. You can call follow this same procedure
# from downstream slim.ini files to register your own templates
#
::Slim::ClearLazyTemplateTable
source [file join $templates _basicTemplates.ini]
set legacyPattern "legacy*"
source [file join $templates _legacyTemplates.ini]
if {$clientmode ne "mtor"} {
    source [file join $templates _rfmTemplates.ini]
    lappend legacyPattern mtor*
}

::Slim::RegisterLazyTemplates {} -legacyPattern $legacyPattern


# Load allPurpose templates based on the TemplateSuite pref
# if allPurpose isn't in the list of template suites, then it is 
# loaded as legacy

::Slim::ClearLazyTemplateTable
set legacyPattern ""

source [file join $templates _allPurposeSuite.ini]
if {[lsearch [GetPref TemplateSuite]  "allPurpose"] eq -1} {
    #set the legacy pattern to match all allpurpose templates
    lappend legacyPattern *
}
::Slim::RegisterLazyTemplates {} -legacyPattern $legacyPattern

::Slim::ClearLazyTemplateTable
set legacyPattern ""
if {$clientmode eq "mtor"} {
    source [file join $templates _mtorTemplates.ini]
}
::Slim::RegisterLazyTemplates {} -legacyPattern $legacyPattern

# Imported shaders ---------------------------------------------------------
# This is currently only used in combination with MTOR
#
if {$clientmode == "mtor"} {
    # This table is used to register shaders and procedurals
    # and configure the "Import Appearance" menu (below)
    #
    set externalAppearanceList {
        {ratCollector.slo           surface  "RAT Collector"  /Surface/Utility }
        {Mondo.slo                  surface  "Mondo"          /Surface }
        {smokeNfire.slo             surface  "Smoke and Fire" /Surface }
        {magicSurf.slo              surface  "Magic Surface"  /Surface }
        {cmarble.slo                surface  "CMarble"        /Surface }
        {shinymetal.slo             surface  "Shiny Metal"    /Surface }
        {spatter.slo                surface  "Spatter"        /Surface }
        {stippled.slo               surface  "Stippled"       /Surface }
        {stone.slo                  surface  "Stone"          /Surface }
        {defaultsurface.slo         surface  "Default"        /Surface/Utility }
        {constant.slo               surface  "Constant"       /Surface/Utility }
        {matte.slo                  surface  "Matte"          /Surface }
        {plastic.slo                surface  "Plastic"        /Surface }
        {glassrefr.slo              surface  "Traced Glass"   /Surface }
        {aachrome.slo               surface  "Chrome"         /Surface }
        {carpet.slo                 surface  "Carpet"         /Surface }
        {wood.slo                   surface  "Wood"           /Surface }

        {ratUberlight.slo           light    "UberLight"      /Light }
        {mtorSpotLight.slo          light    "Spot"           /Light }
        {mtorDirectionalLight.slo   light    "Directional"    /Light }
        {ratBarnDoor.slo            light    "Barn Door"      /Light }
        {ratEnvironment.slo         light    "Environment"    /Light }
        {volumeSpot.slo             light    "Volume Spot"    /Light }
        {magicLight.slo             light    "Magic Light"    /Light }
        {disklight.slo              light    "Disk"           /Light }
        {cylinderlight.slo          light    "Cylinder"       /Light }
        {rectanglelight.slo         light    "Rectangle"      /Light }
        {spherelight.slo            light    "Sphere"         /Light }
        {linearlight.slo            light    "Linear"         /Light }
        {indirectlight.slo          light    "Indirect"       /Light }
        {causticlight.slo           light    "Caustic"        /Light }

        {fog.slo                    volume   "Fog"            /Volume }
        {depthcue.slo               volume   "Depth Cue"      /Volume }
        {volumeSmoke.slo            volume   "Smoke"          /Volume }
        {ratmosphere.slo            volume   "RATmosphere"    /Volume }

        {plugins/mtorUltraFur.slim  RIBGen   "UltraFur"       /RIBGen }
        {plugins/mtorFur.slim       RIBGen   "Fur"            /RIBGen }
        {plugins/mtorFuzz.slim      RIBGen   "Fuzz"           /RIBGen }
        {plugins/quadrics.slim      RIBGen   "Quadrics"       /RIBGen }
    }


    #
    #  "Import Appearance" menu initialization
    #

    # clear import menu
    ::Slim::ClearImportMenuDescriptions
    # register the external appearances listed above
    ::Slim::RegisterImportedAppearances $externalAppearanceList

    # This preference defines the structure of the "Import Appearance" menu
    # The contents (referenced using the "_menuDesc" macro) are defined above.
    # When referring to _menuDesc macros for this menu, you must use
    # the "Import" prefix.
    #
    SetPref ImportAppearanceMenu {
        {   _cascade Surface {
            {_menuDesc Import/Surface}
        }
        }
        {   _cascade Light {
            {_menuDesc Import/Light}
        }
        }
        {   _cascade Volume {
            {_menuDesc Import/Volume}
        }
        }
        {   _cascade RIBGen {
            {_menuDesc Import/RIBGen}
        }
        }
    }
} else {
    SetPref ImportAppearanceMenu {}
}

